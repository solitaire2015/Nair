// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "tair_serv.h"
#include <tair_client_api.hpp>
#include <concurrency/ThreadManager.h> //zml
#include <concurrency/PosixThreadFactory.h> //zml

#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <server/TNonblockingServer.h> //zml    

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace::apache::thrift::concurrency; //zml  
using boost::shared_ptr;

using namespace  ::tair_thrift;

using namespace  ::tair;

using namespace ::common;

class tair_servHandler : virtual public tair_servIf {
 public:
	 tair_servHandler()
	 {
		 api = tair::tair_client_api();
	 }

	 ~tair_servHandler() {
		 api.close();
	 }

  bool Tair_begin(const std::string& master_addr, const std::string& slave_addr, const std::string& group_name) {
	    bool result;
		return result = api.startup(master_addr.c_str(), slave_addr.c_str(), group_name.c_str());
  }

  void Tair_set_loglevel(const std::string& level) {
		api.set_log_level(level.c_str());
  }

  int64_t Tair_put(const int64_t area, const std::string& key, const std::string& data, const int64_t expire, const int64_t version) {
		const data_entry  keyEntry = data_entry(key.c_str(), true);
		data_entry  DataEntry = data_entry(data.c_str(), true);
		return api.put(area, keyEntry, DataEntry, expire, version);
  }

  void Tair_get(std::string& _return, const int64_t area, const std::string& key) {
		data_entry* result;
		const data_entry  keyEntry = data_entry(key.c_str(), true);
		if(api.get(area, keyEntry,result)==0)
		{
		char * p = new char[result->get_size()+1];
		memset(p,0,'\0');
		memcpy(p,result->get_data(),result->get_size());
		_return = string(p);
		delete[] p;
		}
  }

  int64_t Tair_remove(const int64_t area, const std::string& key) {
	  const data_entry  keyEntry = data_entry(key.c_str(), true);
	  return api.remove(area, keyEntry);
  }
public:
	tair_client_api api;
};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<tair_servHandler> handler(new tair_servHandler());
  shared_ptr<TProcessor> processor(new tair_servProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory()); //PosixThreadFactory可以自定义（继承于ThreadFactory）

  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(100);
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  TNonblockingServer server(processor, protocolFactory, port, threadManager);
  //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;}

